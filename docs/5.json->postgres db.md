Of course. It's an excellent idea to document this major upgrade. A developer's second most important skill, after writing code, is writing clear documentation for it.

Here is a complete, standalone guide for migrating the application from a `users.json` file to a PostgreSQL database. It's written to be clear and educational for anyone who wants to follow in your footsteps.

***

### **Project Documentation: Migrating to a PostgreSQL Database**

This document provides a comprehensive guide for upgrading the application's data storage from a simple `users.json` file to a robust, professional PostgreSQL database.

#### **1. What This Feature Is About (The "Why")**

**The Problem:** The original `users.json` file, while great for learning, is not a real database. It is not scalable, it's inefficient for searching, and it's unsafe for an application that might have many users interacting with it at once.

**The Solution:** We are replacing the file-based storage with **PostgreSQL**, a powerful and highly reliable open-source **SQL** (Structured Query Language) database. This migration makes our application faster, more secure, and ready for real-world use. It also introduces professional backend development concepts like database schemas, SQL queries, and connection management.

#### **2. Tools We Will Use**

*   **PostgreSQL:** An industry-standard relational database, known for its stability and advanced features.
*   **`pg` (node-postgres):** The official Node.js driver (library) that allows our Express server to connect to and communicate with our PostgreSQL database.

---

### **3. Step-by-Step Implementation Guide**

#### **Step 1: Install and Set Up a PostgreSQL Server**

Before the application can use a database, the database must exist.

1.  **Install PostgreSQL:** Download and install PostgreSQL for your operating system.
    *   **Mac:** [Postgres.app](https://postgresapp.com/) is the simplest option.
    *   **Windows:** Use the official installer from the [PostgreSQL website](https://www.postgresql.org/download/windows/).
    *   *Note: During installation, you may be asked to set a password for the default `postgres` user. Remember it.*

2.  **Create a New Database:** It is best practice to create a separate database for each application. After installation, connect to your server using a tool like **pgAdmin** or the command-line tool **`psql`**.

    *   In `psql`, run the following command:
        ```sql
        CREATE DATABASE user_login_app;
        ```

3.  **Create the `users` Table:** After creating and connecting to your new database, you must define the structure of your data by creating a table.

    *   Run this SQL command to create the table schema:
        ```sql
        CREATE TABLE users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(255) UNIQUE NOT NULL,
            password TEXT NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );
        ```
    *   **Schema Explanation:**
        *   `id SERIAL PRIMARY KEY`: An auto-incrementing, unique ID for every user.
        *   `username VARCHAR(255) UNIQUE NOT NULL`: A text field for the username that must be unique.
        *   `password TEXT NOT NULL`: A text field to store the long, hashed password.
        *   `created_at ...`: A timestamp that automatically records when each user was created.

#### **Step 2: Add the `pg` Library to the Project**

Install the Node.js driver for PostgreSQL. In your project's terminal, run:

```bash
npm install pg
```

#### **Step 3: Update `server.js` to Connect and Query the Database**

This is the main step where we replace all file system logic (`fs`) with database logic. The entire `server.js` file should be replaced with the following code:

```javascript
const express = require('express');
const path = require('path');
const session = require('express-session');
const bcrypt = require('bcrypt');
const { Pool } = require('pg');

const app = express();
const port = 3000;

// ======================================================
// 1. DATABASE CONNECTION
// ======================================================
const pool = new Pool({
    user: 'user01',
    host: 'localhost',
    database: 'user_login_app',
    password: '',
    port: 5000,
});

// ======================================================
// 2. MIDDLEWARE
// ======================================================
app.use(express.json());
app.use(session({
    secret: 'a-super-secret-key-that-should-be-changed',
    resave: false,
    saveUninitialized: false,
    cookie: { maxAge: 1000 * 60 * 60 }
}));

// ======================================================
// 3. API ROUTES
// ======================================================

// --- REGULAR USER API ROUTES ---
app.post('/register', async (req, res) => {
    const { username, password } = req.body;
    try {
        const hashedPassword = await bcrypt.hash(password, 10);
        await pool.query(
            "INSERT INTO users (username, password) VALUES ($1, $2)",
            [username, hashedPassword]
        );
        res.status(200).send('User registered successfully.');
    } catch (err) {
        if (err.code === '23505') {
            return res.status(400).send('Username already exists.');
        }
        console.error("Error in /register:", err);
        res.status(500).send('Error registering user.');
    }
});

app.post('/login', async (req, res) => {
    const { username, password } = req.body;
    try {
        const result = await pool.query("SELECT * FROM users WHERE username = $1", [username]);
        const user = result.rows[0];
        if (user && await bcrypt.compare(password, user.password)) {
            res.status(200).send('Login successful.');
        } else {
            res.status(400).send('Invalid username or password.');
        }
    } catch (err) {
        console.error("Error in /login:", err);
        res.status(500).send('Server error during login.');
    }
});

// --- ADMIN API ROUTES ---
const ADMIN_USER = { username: 'admin', password: 'mypassword' };

// UPDATED: Admin Login with a debugging console.log
app.post('/admin/login', (req, res) => {
    const { username, password } = req.body;
    
    // =========================================================================
    // DEBUGGING LINE: This will print the received credentials to your terminal.
    console.log("Admin login attempt received with:", { username: username, password: password });
    // =========================================================================

    if (username === ADMIN_USER.username && password === ADMIN_USER.password) {
        req.session.isAdmin = true;
        console.log("Admin login successful.");
        res.status(200).send('Admin login successful.');
    } else {
        console.log("Admin login failed. Credentials do not match.");
        res.status(401).send('Invalid admin credentials.');
    }
});

app.post('/admin/logout', (req, res) => {
    req.session.destroy(() => {
        console.log("Admin session destroyed.");
        res.send('Logged out');
    });
});
function requireAdmin(req, res, next) {
    if (req.session.isAdmin) {
        next();
    } else {
        res.status(403).send('Forbidden');
    }
}
app.get('/api/admin/status', (req, res) => {
    res.json({ loggedIn: !!req.session.isAdmin });
});

app.get('/api/users', requireAdmin, async (req, res) => {
    try {
        const result = await pool.query("SELECT username FROM users ORDER BY created_at ASC");
        res.status(200).json(result.rows);
    } catch (err) {
        console.error("Error in GET /api/users:", err);
        res.status(500).send('Server error.');
    }
});

app.delete('/api/users/:username', requireAdmin, async (req, res) => {
    const { username } = req.params;
    try {
        const deleteOp = await pool.query("DELETE FROM users WHERE username = $1", [username]);
        if (deleteOp.rowCount === 0) {
            return res.status(404).send('User not found.');
        }
        res.status(200).send(`User '${username}' deleted successfully.`);
    } catch (err) {
        console.error("Error in DELETE /api/users:", err);
        res.status(500).send('Server error.');
    }
});

app.put('/api/users/:username', requireAdmin, async (req, res) => {
    const { username } = req.params;
    const { newPassword } = req.body;
    try {
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        const updateOp = await pool.query(
            "UPDATE users SET password = $1 WHERE username = $2",
            [hashedPassword, username]
        );
        if (updateOp.rowCount === 0) {
            return res.status(404).send('User not found.');
        }
        res.status(200).send(`Password for '${username}' updated successfully.`);
    } catch (err) {
        console.error("Error in PUT /api/users:", err);
        res.status(500).send('Server error.');
    }
});

// ======================================================
// 4. PAGE SERVING & STATIC FILES
// ======================================================
app.get('/admin', (req, res) => { res.sendFile(path.join(__dirname, 'admin.html')); });
app.get('/', (req, res) => { res.sendFile(path.join(__dirname, 'index.html')); });
app.use(express.static(__dirname));

// ======================================================
// 5. SERVER INITIALIZATION
// ======================================================
app.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
    console.log(`Admin dashboard at http://localhost:${port}/admin`);
});
```

#### **Step 4: Clean Up and Test**

1.  **Delete the `users.json` file** from your project. It is no longer needed and should be removed.
2.  **Restart your server** (`node server.js`).
3.  **Test all functionality:**
    *   Register a new user.
    *   Log in and log out with that user.
    *   Log in as an admin.
    *   View the user list, update a user's password, and delete a user.
    *   Verify the changes by looking directly at your `users` table in your database.

You have now successfully and completely migrated your application's data layer to a professional PostgreSQL database, making it more secure, scalable, and robust.